---
title: "Data Wrangling for Visualization"
author: "Jeremy Mikecz"
format: html
editor: visual
---

# Tidy Weather: Data Wrangling for Visualization, Part 1

In this lesson we will import a dataset of local weather data and modify it to answer the question: how has Hanover's data changed over time? Then, we will create a basic line graph showing this change.

When searching for local weather data, I found [*Climate Data Online*](https://www.ncei.noaa.gov/cdo-web/) found on NOAA's National Centers for Environmental Information website. I chose "Hanover", the type of data I wanted, and the date range (earliest to present). Next, I requested this data, and downloaded it from a link they sent me.

# 1. Setup

## 1.1 Import necessary packages

```{r}
library(tidyverse)
library(zoo)

```

## 1.2 Import Data

```{r}
df <- read.csv("../data/Hanover_weather-data_1884-2025.csv")

```

# 2. Review Data

To learn more about this data, we can review some descriptive statistics of the data using the functions below. Do you notice any of the following:

-   missing data?

-   data fields with inconsistent formats?

-   any extreme outliers?

We should also review the Climate Online documentation (which is in the "week2/data" folder) for more information on what these fields or columns are recording and how this data was measured / recorded / computed.

```{r}
head(df)
```

```{r}
summary(df)
```

```{r}
# install.packages("Hmisc")
library(Hmisc)
describe(df)
```

# 3. Planning

We would like to examine changes in Hanover's temperature over time.

Brainstorm how you would need to modify this dataset to do this analysis. Write your thoughts below:

```         



```

# 4. Tidyverse / dplyr verbs for Data Wrangling

To modify and "wrangle" datasets, the tidyverse commonly uses the following verbs / functions:

-   **select()**: to select specific columns by their names or data types

-   **arrange()**: to order rows by one or more columns

-   **rename()**: to rename columns

-   **mutate()**: to create columns

-   **filter()**: to filter out rows by a given condition

-   **distinct()**: to keep only distinct / unique rows

-   **gather()**: to make "wide" data longer

-   **spread()**: to make "long" data wider

-   **separate()**: to split a single column into multiple columns

-   **unite()**: to combine multiple columns into one

[More tidyverse verbs and functions here](https://dplyr.tidyverse.org/reference/index.html). Review the *Intro to Tidyverse* notebook for practice using some of these functions.

# 5. Subsetting the dataset

For our first analysis of temperature change, we will focus on the variables `TMAX` (daily maximum temperature) and `TMIN` (daily minimum temperature). We will also average these two variables by year, which will allow us to greatly reduce the size of the dataset.

To do that, we will need to follow these steps:

1.  keep only needed columns
2.  extract the year from the `DATE` column and place it in the new column `YEAR`.
3.  group the dataset by year by calculating the average `TMAX` and `TMIN` for each year.

To keep select columns we can use the `select` function:

```{r}
subdf <- df |>
    select(NAME, DATE, TMIN, TMAX)
```

If all dates were recorded in a consistent format, i.e. YYYY-MM-DD, we could just extract the first four characters from the `DATE` column using **mutate()** to create a new column and **substr()** to extract the first four characters from the `DATE` column:

```         
subdf <- subdf |>
    mutate(YEAR = substr(DATE, 1, 4))
```

Unfortunately, often things aren't so simple. Let's review the `DATE` column again:

```{r}
print(head(subdf$DATE))
print(tail(subdf$DATE))
```

We can use the **lubridate** package (already imported) to standardize dates:

```{r}
library(lubridate)
subdf <- subdf |>
    mutate(DATE2 = parse_date_time(DATE, orders = c("ymd", "mdy"))) |>
    mutate(DATE2 = as.Date(DATE2))
```

```{r}
print(head(subdf$DATE2))
print(tail(subdf$DATE2))
```

Now we can create the new `YEAR` column using **lubridate** as well (we could also use **substr** as well now that the dates are all in the same format):

```{r}
subdf <- subdf |>
    mutate(YEAR = year(ymd(DATE2)))
```

# 6. Grouping Data: Split-Apply-Combine

A common technique in data science is to **split** a dataset into groups, perform or **apply** an action on each group (i.e. calculating the sum, mean, min, or max for all observations in a group), and then re-**combining** that data into a new aggregated dataset.

One example:

```         
You have a dataset of individual statistics for a women's basketball league. You may want to analyze differences in performance by position, so you split the dataset by position (guard, forward, center), calculate the mean of common basketball metrics (points, rebounds, assists) for each group, and then re-combine the results. Or, you may want to compare teams by calculating the sum of each team's metrics and then averaging those totals by the number of games played to allow comparison between teams that have played different numbers of games
```

![Split-apply-combine technique for splitting data into groups, applying an action to each group, and then re-combining the resulting data.](https://miro.medium.com/v2/resize:fit:720/format:webp/0*m-puRNwcnUl5zZ4O){fig-alt="Graphic shows data from the famous iris flower dataset. On the left, is a table of multiple measurements (sepal length & width, petal length & width) for multiple observations of three species of iris flower: setosa, versicolor, and virginia. Data for each group (in this case, species) is added or summed up for each species and these sums are then re-combined in a new dataset on the right."}

To group the dataset by year and calculate average minimum and maximum temperatures across an entire year we should use the **group_by** function to group by `YEAR` and the **summarise()** function to create a new column that calculates the average of `TMAX` and `TMIN` by year. The aggregated results are then re-combined in the new `yearly_temps` dataframe.

```{r}
yearly_temps <- subdf |>
    group_by(YEAR) |>
    summarise(
        avg_TMAX = mean(TMAX, na.rm = TRUE),
        avg_TMIN = mean(TMIN, na.rm = TRUE)
    )
```

If you review the new dataframe by running `view(yearly_temps)` or opening `yearly_temps` using the Environment pane to the right, you may notice it is missing data for the years 1884 - 1892. Furthermore, on first glance, the temperatures for 1893 seem abnormally high. Closer review of the dataset indicates that the the first recorded temperatures are from the summer of 1893. This data also ends in March 2025, thus producing abnormally low averages for 2025. So, for consistency, let's remove all years before 1894 and after 2024:

```{r}
yearly_temps <- yearly_temps |>
    filter(YEAR >= 1894 & YEAR <= 2024)
```

We could have done all these modifications from the previous section and this section, of course, in one code cell. Below, I am creating a dataframe with the slightly different name `yearly_temps2` so we can verify that, indeed, they produce the same results.

*Note: now that I know the code works, I did not create any intermediary dataframes (i.e. `subdf`*) or intermediary data columns (`DATE2`).

```{r}
yearly_temps2 <- df |>
    select(NAME, DATE, TMIN, TMAX) |>
    mutate(DATE = parse_date_time(DATE, orders = c("ymd", "mdy"))) |>
    mutate(DATE = as.Date(DATE)) |>
    mutate(YEAR = year(ymd(DATE))) |>
    group_by(YEAR) |>
    summarise(
        avg_TMAX = mean(TMAX, na.rm = TRUE),
        avg_TMIN = mean(TMIN, na.rm = TRUE)
    ) |>
    filter(YEAR >= 1894 & YEAR <= 2024)

# check if two dataframes are identical
identical(yearly_temps, yearly_temps2)
```

We should save this dataset before doing anything else:

```{r}
write.csv(yearly_temps, "../data/Hanover_yearly-temp-averages_1894-2024.csv")
```

# 6. Tidying the Data: Wide to Long

At times, you will need to convert a dataframe from wide format to long (or vice-versa).

The long format is often, but not always, preferred for data analysis. In particular, you want each row of your data to represent one observation. Thus, for our temperature data, one observation is not multiple metrics for a given year (that would be multiple observations) but, rather, one metric per year. To convert a dataset into such a long format, we will have to move all values into one column (sometimes called `value` but in this case `average_yearly_temp` or `T_yravg` is more descriptive) and record the type of value being recorded in other column (in a column called `type`).

```{r}
head(yearly_temps)
```

```{r}
yearly_temps_long <- yearly_temps |>
    pivot_longer(
        cols = c(avg_TMAX, avg_TMIN),
        names_to = "type",
        values_to = "T_yravg",
    ) |>
    mutate(
        type = case_when (
            type == "avg_TMAX" ~"maxtemp",
            type == "avg_TMIN" ~"mintemp",
            TRUE ~type
        )
    )
head(yearly_temps_long)
```

```{r}
write.csv(yearly_temps_long, "../data/Hanover_yearly-temp-averages_long_1894-2024.csv")
```

# 7. Visualizing with wide dataset

Creating long dataframes is often recommended for data visualization.

Generally, you want one row per observation. In this case, wide and long dataframes answer the question - what is an observation here? - in different ways.

The wide dataset contains one row per year. However, since we want to visualize both yearly maximum and minimum temperatures, each year will actually contain two separate observations. Thus, the long dataset is better because it contains one row for every observation we want to record.

Nonetheless, R and ggplot will still work with the wide dataset. Here, we just create two distinct lines using two separate **geom_line** functions.

```{r}
ggplot(data=yearly_temps) +
    geom_line(aes(x=YEAR, y=avg_TMAX), color="red") +
    geom_line(aes(x=YEAR, y=avg_TMIN), color="blue")
```

We can add a 10-year rolling average using the **rollmean()** function from the **zoo** library and a more useful y-axis label.

```{r}
ggplot(data=yearly_temps, aes(x=YEAR)) +
    geom_line(aes(y=avg_TMAX), color="red", linewidth=1, alpha=0.5) + 
    geom_line(aes(y=rollmean(avg_TMAX, 10, na.pad=TRUE)), linetype="dashed") +
    geom_line(aes(y=avg_TMIN), color="blue", linewidth=1, alpha=0.5)+
    geom_line(aes(y=rollmean(avg_TMIN, 10, na.pad=TRUE)), linetype="dashed") +
    ylab("Temperature (yearly average)") + 
    ggtitle("Yearly Average Temperatures with 10-Year Rolling Mean")
```

# 8. Climate vs. Weather

Or, we can just show the 10-year rolling mean to remove the noise of year-to-year variability and instead focus on long-term climate patterns. This time, we will also use the **labs** function to add a subtitle.

```{r}
ggplot(data=yearly_temps, aes(x=YEAR)) +
    geom_line(aes(y=rollmean(avg_TMAX, 10, na.pad=TRUE)), color="red", linetype="dashed") +
    geom_line(aes(y=rollmean(avg_TMIN, 10, na.pad=TRUE)), color="blue", linetype="dashed") +
    ylab("Temperature (yearly average)") + 
    labs(
        title = "Tracking Changes to Temperature, Hanover NH",
        subtitle = "10-Year Rolling Mean of Average Yearly Maximum and Minimum Temperatures"
    )
```

# 9. Visualizing with long dataset

Here, we will try using the long dataset. Instead of containing two separate values (max and min temps) for each year within the same row, this dataset contains one value per row and identifies that value as being either a maximum or minimum temperature.

```{r}
ggplot(data = yearly_temps_long) +
  geom_line(aes(x = YEAR, y = T_yravg, color = type))
```

If we want to customize the selection of colors, we can use the **scale_color_manual** function:

```{r}
ggplot(data = yearly_temps_long) +
  geom_line(aes(x = YEAR, y = T_yravg, color = type)) +
  scale_color_manual(
    values = c(maxtemp = "red", mintemp = "blue"),
    name = "Temperature Type"
  )
```

Now, below, we insert a 10-year rolling mean just as we did above, but this time using the long dataset.

Note: even though using datasets in long form is often recommended, in this case, the code got more complex when working with the long form data. Instead of creating two separate lines for max and min temps and two more for max and min 10-year rolling means, we need to group the data by temperature type to calculate the rolling means.

```{r}
# Compute rolling means by group (type)
yearly_temps_rolled <- yearly_temps_long %>%
  arrange(type, YEAR) %>%
  group_by(type) %>%
  mutate(
    rollmean_10 = rollmean(T_yravg, k = 10, fill = NA, align = "center")
  ) %>%
  ungroup()

ggplot(data = yearly_temps_rolled, aes(x = YEAR, color = type)) +
  geom_line(aes(y = T_yravg), linewidth = 0.5, alpha = 0.6) +
  # we need to group by type below so that it creates two separate lines in the color "gray25"
  geom_line(aes(y = rollmean_10, group=type), linewidth=1, color="gray25", linetype = "dashed") +
  scale_color_manual(
    values = c(maxtemp = "red", mintemp = "blue"),
    name = "Temperature Type"
  ) +
  ylab("Temperature (yearly average)") +
  ggtitle("Yearly Average Temperatures with 10-Year Rolling Mean")
```

# 
